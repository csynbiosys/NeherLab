function [model] = COVID19_NeherModel_Test1()

model.AMIGOjac = 0;                                                         % Compute Jacobian 0 = No, 1 = yes
model.input_model_type='charmodelC';                                        % Model introduction: 'charmodelC'|'c_model'|'charmodelM'|'matlabmodel'|'sbmlmodel'|'blackboxmodel'|'blackboxcost                             

model.n_st=18;                                                               % Number of states      
model.n_par=16;                                                             % Number of model parameters 
model.n_stimulus=1;                                                         % Number of inputs, stimuli or control variables   
model.stimulus_names=char('Mt');                                % Name of stimuli or control variables
model.st_names=char('S_1','E_11','E_12','E_13','I_1','H_1','C_1','R_1','D_1', ...
                    'S_2','E_21','E_22','E_23','I_2','H_2','C_2','R_2','D_2');      % Names of the states     
                
model.par_names=char('N','R0','ep','cos_phase','t_i','t_l','t_c', 't_h',...
                     'ze_1','m_1','c_1','f_1', ...
                     'ze_2','m_2','c_2','f_2');  % Names of the parameters    

% cos_phase is cos(2*pi*(t-tmax)), since I am not sure pi and cos will be
% valid options (just in case untill tested)
model.eqns=...                                                              % Equations describing system dynamics. Time derivatives are regarded 'd'st_name''
               char('dS_1 = -(1/N)*(ze_1*R0*Mt*(1+ep*cos_phase)/t_i)*S_1*(I_1+I_2)',...
                    'dE_11 = (1/N)*(ze_1*R0*Mt*(1+ep*cos_phase)/t_i)*S_1*(I_1+I_2) - 3*E_11/t_l',...
                    'dE_12 = 3*E_11/t_l - 3*E_12/t_l',...
                    'dE_13 = 3*E_12/t_l - 3*E_13/t_l',...
                    'dI_1 = 3*E_13/t_l - I_1/t_i',...
                    'dH_1 = (1-m_1)*I_1/t_l + (1-f_1)*C_1/t_c - H_1/t_h',...
                    'dC_1 = c_1*H_1/t_h - C_1/t_c',...
                    'dR_1 = m_1*I_1/t_i + (1-c_1)*H_1/t_h',...
                    'dD_1 = f_1*C_1/t_c',... 
                    ...
                    'dS_2 = -(1/N)*(ze_2*R0*Mt*(1+ep*cos_phase)/t_i)*S_2*(I_1+I_2)',...
                    'dE_21 = (1/N)*(ze_2*R0*Mt*(1+ep*cos_phase)/t_i)*S_2*(I_1+I_2) - 3*E_21/t_l',...
                    'dE_22 = 3*E_21/t_l - 3*E_22/t_l',...
                    'dE_23 = 3*E_22/t_l - 3*E_23/t_l',...
                    'dI_2 = 3*E_23/t_l - I_2/t_i',...
                    'dH_2 = (1-m_2)*I_2/t_l + (1-f_2)*C_2/t_c - H_2/t_h',...
                    'dC_2 = c_2*H_2/t_h - C_2/t_c',...
                    'dR_2 = m_2*I_2/t_i + (1-c_2)*H_2/t_h',...
                    'dD_2 = f_2*C_2/t_c');


                
                
                
                
model.par=[1,1,1,1,1,1,1,1,...
          1,1,1,1,...
          1,1,1,1];  






















end